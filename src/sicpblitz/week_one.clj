; 1.5
(defn p [] (p))
(defn test [x y] (if (= x 0) 0 y))

; should overflow - call to (p) will be evaluated
(test 0 (p))

; 1.6
(defn my-if [pred tru fal] (cond pred tru :else fal))


(my-if false :true :false) ; will work ok
(my-if false :true (p)) ; same problem - arguments are evaluated. if we pass a recursive call as either branch, it'll be evaluated, undesired.


; Iteration v recursion
; When we build a chain of deferred operations we call it recursion. When we simply update state variables we iterate (even if we recurse by calling the original fn to implement the iteration).

; 1.9 Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

; recursive - our return value depends on a call to add' operation
(defn add' [a b]
  (if (= a 0)
      b
      (inc (add' (dec a) b))))

; (add' 4 5)
; (inc (add' 3 5))
; (inc (inc (add' 2 5)))
; (inc (inc (inc (add' 1 5))))
; (inc (inc (inc (inc (add' 0 5)))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9


; iterative - return value passes complete next state to add''
(defn add'' [a b]
  (if (= a 0)
      b
      (add'' (dec a) (inc b))))

; (add'' 4 5)
; (add'' (dec 4) (inc 5))
; (add'' (dec 3) (inc 6))
; (add'' (dec 2) (inc 7))
; (add'' (dec 1) (inc 8))
; (add'' (dec 0) (inc 9))
; 9


; 1.32
(defn accumulate [combiner null-value term a nxt b]
  (if (>= a b)



(accumulate + 0 + 1 inc 10)
(accumulate * 0 id 1 inc 10)

(accumulate ++ [] id  inc 10)

